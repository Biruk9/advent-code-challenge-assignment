Solving the Corrupted Memory mul(X,Y) Problem _ part1




The task was to analyze a corrupted memory file from a shopkeeper's computer. The memory contained instructions meant to multiply two numbers in the form:

mul(X,Y)


Where X and Y are 1-3 digit numbers.

However, the memory was corrupted with random characters, extra symbols, and invalid sequences that resembled mul instructions but were not valid. Only strictly formatted mul(X,Y) instructions were valid. Examples of invalid sequences include:

-mul(4*

-mul(6,9!

-?(12,34)

-mul ( 2 , 4 ) (note the space after mul)

The goal was to sum the results of all valid mul(X,Y) instructions.

Approach
Step 1: Read the Memory File

Open the file input3.txt for reading.

Read the entire content into a large buffer (size 100,000) to facilitate scanning for instructions.

Null-terminate the string to mark the end.

char buffer[100000];
int idx = 0;
char c;
while ((c = fgetc(f)) != EOF) {
    buffer[idx++] = c;
}
buffer[idx] = '\0';

Step 2: Scan for Valid mul(X,Y) Instructions

Iterate over the buffer character by character.

Look for the exact sequence "mul(" without extra spaces or symbols.

Extract the numbers X and Y by checking that each character is a digit.

Skip spaces before and after the comma.

Verify that the instruction ends with a closing parenthesis ).

Ignore sequences that do not exactly match the valid format.

if (buffer[i] == 'm' && buffer[i+1] == 'u' && buffer[i+2] == 'l' && buffer[i+3] == '(') {
    // Extract X
    int X = 0;
    i += 4;
    while (isdigit(buffer[i])) { X = X*10 + (buffer[i]-'0'); i++; }

    // Skip spaces and check comma
    while (buffer[i]==' ') i++;
    if (buffer[i] != ',') continue;
    i++;
    while (buffer[i]==' ') i++;

    // Extract Y
    int Y = 0;
    if (!isdigit(buffer[i])) continue;
    while (isdigit(buffer[i])) { Y = Y*10 + (buffer[i]-'0'); i++; }

    // Skip spaces and check closing parenthesis
    while (buffer[i]==' ') i++;
    if (buffer[i] != ')') continue;

    total += X*Y;
}

Step 3: Sum the Results

For each valid instruction, calculate X * Y and add it to a running total.

At the end, print the total sum.

printf("Total sum of all mul(X,Y) instructions: %d\n", total);

Validation is strict: Only sequences that exactly match mul(X,Y) without extra characters or misplaced spaces are counted.

Digits extraction: Each number is parsed digit by digit to handle multiple digits (1-3 digits per the problem statement).

Ignoring corrupted memory: Any malformed or partial sequences are ignored automatically.

Efficiency: Reading the file into a buffer allows scanning the entire memory quickly in a single pass.

Result

After scanning the entire corrupted memory, the sum of all valid multiplication instructions was: 163931492

compile the program with "gcc day3_part2.c -o day3_part2.exe"
